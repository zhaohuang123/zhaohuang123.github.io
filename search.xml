<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LongestPalindromicSubstring]]></title>
    <url>%2F2018%2F08%2F19%2FLongestPalindromicSubstring%2F</url>
    <content type="text"><![CDATA[本文主要是介绍利用动态规划与Manacher 算法求解最长回文子串，LeetCode链接 动态规划问题分析对于最长回文子串的求解可以抽象为一个动态规划的多阶段决策过程。例如，对于对于字符串S”ababa”回文判断，如果我们知道该回文字符串的子串s”bab”为回文字符串的话，那么显然对于字符串S的判断，只需要判断S左右两端字符是否一致即可。若S左右两端的字符相同，则在s为回文串的前提下，S为回文字符串；若两端字符不相同，则S不是回文字符串。 多阶段决策过程抽象基于上述的问题分析，假设需要判断的字符串S[i:j]是否为回文串，那么该决策过程可以分解为两步，首先判断子串S[i+1:j-1]是否为回文串，若不是，则S串不是回文字符串；若该子串是回文串，且S[i]等于S[j]，则S为回文字符串。因此，对于任一字符串S[i:j]，我们可以定义二维数组P表示该字符串状态，其中$i &lt; j$： P(i,j)=\begin{cases} true, 如果S[i:j]是回文串\\ false, 非回文串\\ \end{cases}基于上述二维数组，可以定义如下状态转移方程： P(i,j)=(P(i+1,j-1) and S[i] == S[j])上述状态转移方程表示的含义即为$P(i,j)$为true的条件为$P(i+1,j-1)$为真（即S[i+1,j-1]为回文串）且S[i]字符与S[j]字符相等。由于上述状态转移方程之中，必须要求$ i \leq j $ 且 $ i +1 \leq j - 1 $，所以，需要先初始化$i = j $和$ i + 1 = j $的情况，其中$ P[i,i] $初始化为true，$ P[i, i + 1] $依据字符串的实际情况进行。 python实现1234567891011121314151617181920212223242526272829class Solution: def longestPalindrome(self, s): """ :type s: str :rtype: str """ #采用动态规划的方法 DPMa = [[0 for i in range(len(s))] for j in range(len(s))] #初始化二维矩阵，用户动态规划预计算 LenPa = 1 iMax = jMax = 0 for i in range(len(s)): DPMa[i][i] = 1 if i + 1 &lt; len(s) and s[i] == s[i + 1]:#出现相同两位的回文字符串 DPMa[i][i + 1] = 1 LenPa = 2 iMax = i jMax = i + 1 for k in range(2, len(s)): for i in range(0, len(s) - k): j = i + k if DPMa[i + 1][j - 1] and s[i] == s[j]: DPMa[i][j] = 1 if k + 1 &gt; LenPa: LenPa = k + 1 iMax = i jMax = j return s[iMax:jMax + 1] 时间复杂度与空间复杂度时间复杂度：由上述代码实现可以看出，动态规划过程为两重循环，因此时间复杂度为$O(n^2)$空间复杂度：使用了二维数组保存个子串状态，空间复杂度为$O(n^2)$ Manacher 算法利用动态规划解决最长回文子串问题需要 $O(n^2)$ 的时间复杂度，但对于该问题有一种称之为Manacher算法的，$O(n)$的解决方法。以下主要是对LeetCode上关于该算法文章进行翻译、整理而成的（原文） Note这是“最长回文子串”的第二部分。在这篇文章中，我们将分析一个能再线性时间内解决最长回文子串的算法——Manacher算法。在之前的LeetCode的solution中给出了四种不同求解最长回文子串的方法，最简单的算法时间复杂度为$O(n^2)$，空间复杂度为常数级。本文介绍的Manacher算法的时间复杂度和空间复杂度都为O(n). Hint考虑在之前的解决算法之中出现的最坏情况，即输入字符串是多个回文字符串重叠而成的情况。例如，输入字符串是”aaaaaaaa”和”cabcbabcbabcba”。对于出现的这种最坏情况，我们可以利用回文字符串的对称性来避免一些不必要的重复计算。 An O(N) Solution (Manacher’s Algorithm):首先我们需要对输入的字符串进行处理，处理方式为：对输入字符串S，在首尾以及每个字符之插入特殊字符’#’。 例：S=”abaaba”，处理完毕后 T=”#a#b#a#a#b#a#”S为输入原始字符串，T为预处理后的字符串。$S_i$表示S的第i位置的字符，$T_i$表示T的第i位置的字符 经过这样的处理，可以对输入的字符串进行统一化处理。在完成插入操作之后，不论输入的字符串长度是偶数还是奇数，在处理后，字符串长度都将变成奇数长度，并且原字符串中各字符的相对位置不变。 为了找出最长回文子串，我们可以对每一个$Ti$进行如$T(i-d)…T_(i+d)$的扩展来组成一个回文字符串。对于这种扩展，你可以立即看到，d就是以$T_i$为中心扩展而成的回文字符串的长度(这个长度减去了特殊字符’#’的长度))。 我们需要定义一个存储中间结果的数组P，中间数组$P[i]$存储的是以$T_i$为中心的回文字符串的长度。因此，在P数组计算完成之后，最长回文字符子串的中心点索引就是数组P中最大值的索引。对于上述例子，我们可以从左到右手动计算数组P的值，结果如下： T = # a # b # a # a # b # a #P = 0 1 0 3 0 1 6 1 0 3 0 1 0 从上述数组P的值中可以看出，P[6]为6，具有最大值，该索引值对应字符子串是”abaaba”，由原始输入字符串可知，该字符串即为最长回文子串。 若是在回文字符串”abaaba”画一条中轴线，可以看到P数组的值将根据该中轴线对称分布。这不仅仅是这一个回文串的性质，对于任意一回文串，都具有该对称性质。 根据以上性质，让我们考虑一个更加复杂的、具有回文串叠加的字符串S=”babcbabcbaccba”。 上图展示了S字符串在完成特殊插入之后的字符串T。现在先假定你已经到达了P数组被部分完成的状态。实心中轴线表示回文子串”abcbabcba”的中点，两条虚线严格表示该回文串的边界，L和R表示左右边界索引值。基于该中轴线，索引i的镜像位置的索引表示$i^,$。那么接下来的问题是，如何计算数组元素$P[i]$的值？ 假定我们当前需要计算的是当索引为$P[13]$的值。首先我们可以观察其基于以C为中心的回文子串的镜像位置$i^,$索引表示的值。针对$i=13$，其镜像对称位置$i^,$为9。 上图两条绿色的实线表示的是以$i$和$i^,$为中心表示的回文串的覆盖范围。我们可以看到i的镜像位置是$i^,$，$P[i^,]=P[9]=1$。由上图回文字符串基于中心的对称性可知，可以清楚的看到$P[i]=P[13]$的值也是1。 正如之前看到的，由于回文字符串的对称性，$P[i^,]=P[i]=1$显然是正确的。事实上，在上述字符串T中，位于中心点之后的三个元素都符合对称性的要求，即有$P[12]=P[10]=0, P[13]=P[9]=1, P[14]=P[8]=0$。 现在需要考虑的问题是，当i为15时，基于C的镜像位置$i^,=7$，那么是否有$P[15]=P[7]=7$呢？ 现在需要考虑索引为15的时候，$P[i]$的值是多少？如果考虑对称性的话，$P[i]$的值应该与$P[i^,]$的值相同，都为7。但从上图中可以看出，显然这个是不成立的。如果我们以$T_15$为中心进行回文字符串的扩展，将可以组成回文串”a#b#c#b#a”，这个回文串显然是比对称性所计算出来的回文串要小。因此，接下来需要考虑为什么会出现这种情况。 在上图之中，绿色实线表示的区域是以C为中心基于对称性的边界范围。红色的实线表示的是以C为中心对称性不匹配的区域，即不是回文串的部分。绿色的虚线表示的区域是跨越中心的部分。 从上图中，以$i^,=7$以及$i=15$为中心的子串在绿色实线区域内是匹配的非常好的。在穿越中心的部分（绿色虚线部分）也是非常完整的复合对称性的要求。仔细观察可以发现，$P[i^,]=7$，而却其扩展一直延伸穿过了回文字符串的左边缘（直到红色实线部分），红色实线部分就不在属于以C为中心的回文对称性质部分。针对上述$i=15$时，当$P[i]&gt;5$时，我们可以知道，要找出其准确的$P[i]$值，必须对边界R之外的字符串进行格外的匹配。在本例中，因为$P[21] \not= P[1]$，我们可以得出结论，$P[i]=5$。 上述算法要点： if P[i^,] \leq R - i, then P[i] \leftarrow P[i^,] else P[i] \geq R - i上述算法要点，原文关于else的赋值给错了，原文是$P[i] \geq P[i^,]$，应修改为上述表达，表示当前索引串的右边界必定会大于当前右边界 上述步骤就是整个Manacher 算法的核心步骤以及本质。基于上述算法过程，接下来剩下的步骤就是确定我们应该在什么是时候向右移动中心点以及对应的边界R。相比之前的分析，这个问题是非常简单的，移动方式如下： 如果以i为中心的回文串的扩展越过了当前右边界R，我们将更新中心点C为i（即新的回文串的中心），并且我们将边界R扩展到新的回文串的右边界。 从上述算法中可以看出，每一个步骤都存在两种情况：如果$P[i] \leq R - i$，则只有$P[i] = P[i^,]$ 这一个步骤；其他一种情况是，我们需要尝试对右边界进行扩展，并将回文字符串的中心修改为i。扩展右边界R（内部循环完成）最多将花费N步完成（N表示输入字符串的长度），每一个中心点的定位和测试总计将花费N步。因此，这个算法将保证能在最多$2*N$步内完成。因此，该算法的时间复杂度就是O(n)。 python实现原文之中给出了java代码实现，以下是依据该代码的python实现。 123456789101112131415161718192021222324252627282930313233class Solution: def longestPalindrome(self, s): s = Solution.PreProcess(s) #预处理 P = [0] * (len(s)) #p数组，保存回文长度 C = 0 #中心点位置，初始化为0 R = 0 #右边界位置，初始化为0 for i in range(1, len(s) - 1): iMirror = 2*C - i if iMirror &lt; 0: iMirror = 0 # 计算在当前以C为中心的的最大对称位置 P[i] = min(R - i, P[iMirror]) if R &gt; i else 0 # 对边界进行扩展，利用循环对边界进行扩展 while (s[i - 1 - P[i]] == s[i + 1 + P[i]]): P[i] += 1 # 计算新的C和R的位置 if (i + P[i] &gt; R): R = i + P[i] C = i MaxLen = max(P) index = P.index(MaxLen) return s[index - MaxLen: index + MaxLen + 1].replace('#', '') def PreProcess(s): """ 预处理过程，在字符串收尾插入^$ ，在字符串间插入# :param s: 待处理字符串 :return: 处理完成的字符串 """ sList = list('^' + s + '$') return '#'.join(sList) 参考[1] https://articles.leetcode.com/longest-palindromic-substring-part-ii/]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LDA主题模型]]></title>
    <url>%2F2018%2F07%2F27%2FLDAModel%2F</url>
    <content type="text"><![CDATA[本文主要是介绍如何利用sklearn框架中LatentDirichletAllocation类完成LDA模型的训练。 理论基础&emsp;&emsp;LDA是一个无监督的学习模型，它假设每个文档包含多个主题，文档中的每个主题都是基于词的概率分布。作为一个基于贝叶斯网络的文档生成模型，LDA刻画的是文档生成的一个概率化过程。&emsp;&emsp;LDA的输入由一组文档D组成的词料库。LDA的输出包括文档主题分布$\theta$和主题中的词语的分布$\phi$。这里的$\theta$和$\phi$都假设服从多项式分布。为让分布更平滑，再假设这两个参数的先验分布服从狄利克雷分布，参数分别为$\alpha$和$\beta$。因为狄利克雷分布是多项式分布的共轭先验分布，所以假设该多项式分布的先验服从狄利克雷分布可以极大简化统计计算的过程。狄利克雷分布中有多个参数，再LDA中利用狄利克雷分布时，大多将参数设为同一个数值，这种设为同一个数值的狄利克雷分布称为对称的狄利克雷分布。以下时LDA模型生成一篇文档的方式。 按照先验概率$p(d_i)$的方式选择一篇文档$d_i$。 从超参数$\alpha$的狄利克雷分布中取样生成文档$d_i$的多项式主题分布$\theta_i$，即主题分布$\theta_i$由超参数$\alpha$的狄利克雷分布生成。 用$z_{i,j}$表示从主题的多项式分布$\theta_i$中采样生成文档$d_i$第j个词的主题。 从超参数为$\beta$的狄利克雷分布中采样生成主题$z_{i,j}$对应的词语分布$\phi_z$，即词语分布时由超参数$\beta$的狄利克雷分布生成的。 $W_{i,j}$表示从词语多项式分布$\phi_z$中采样生成最终的词语。 刘兵情感分析：挖掘观点、情感和情绪 sklearn常用类CountVectorizer&emsp;&emsp;sklearn常用的文本特征提取类有CountVectorizer和TfidfVectorizer，以下依据sklearn的官方文档对CountVectorizer类中的部分参数做出解释。 input：参数类型为string，当参数为filename 预计时需要读取文件原始内容来进行分析；当参数为 file，官方文档给出的解释必须要有一个read方法来读取内存中的字节内容。具体用法不知；如果不是上述两项参数，则将视为直接进行分析的字符串序列或字节流内容。 encoding：参数类型为string，表示对输入字符串的解码方式，默认值为utf-8， decoder_error: 参数可选为{‘strict’, ‘ignore’, ‘replace’}，表示对输入内容呢，按照encoding参数设置的内容进行解码时，若出现不符合编码方式的错误时的解决办法。默认参数为strict，表示将会抛出UnicodeDecodeError错误；ignore表示忽略当前解码错误；replace参数作用尚不明确。 analyzer：参数可选为{‘word’, ‘char’, ‘char_wb’}，该参数决定特征是否应该由单词或字符的n-gram组成，char_b表示创建的n-gram特征的字符范围为文本字符，n-gram不足部分用空格填充。 preprocessor: 重写预处理阶段，但标记化和n-gram的步骤会保留下来，默认参数为None。 tokenizer：类似于preprocessor参数，重写字符串标记化过程，但会保留预处理和n-gram步骤，该参数当analyer为word时才生效。 ngram_range: n-gram特征提取范围，参数类型为元组(tuple): (min_n, max_n)，在$min_n \leq n \leq max_n$的n-gram都将被提取。 stop_word: 停用词去除参数。参数为’english’时，去除英语中的停用词；当参数为list类型的数据时，会假定该list中包含所有需要去除的停用词，将去除原始文本中该list指向的所有词，该参数当analyzer参数为word时才生效。 lowercase：参数类型为布尔值，默认参数为True，表示是否对文本进行小写化。 max_df: 该参数表示一个最大阈值，当参数类型为float时，参数范围为$[0.0, 1.0]$；当参数类型为int时，默认值为1。在建立词汇表时，若词汇中某个单词出现的频率(float)或次数(int)大于当前阈值时，该单词将不会加入到词汇统计中。 min_df: 该参数类似于max_df，表示最小阈值。 max_features: 参数类型为int，默认值为None。当参数为int时，表示构建的词汇表的词汇仅是语料中词频在排在max_features之前的词。 LatentDirichletAllocation&emsp;&emsp;sklearn中训练LDA主题模型的类是LatentDirichletAllocation。 参数 n_components: 模型训练的预设主题数，参数类型为int，默认值为10。 doc_topic_prior: 即文档主题分布$\theta$的参数$\alpha$，参数类型为float，若参数为None，则$\alpha$参数默认为$1 / n_components$ topic_word_prior: 即主题词语分布$\phi$的参数$\beta$，参数类型为float，若参数为None，则$\beta$参数默认为$1 / n_components$ learning_method: LDA的求解算法，有’batch’和’online’两种，默认为’batch’。当数据规模较大时，’online’将比’batch’更快。 max_iter: 最大迭代次数，参数类型为int。 方法 fit(X[, y]): 利用训练数据训练LDA模型，输入参数为CountVectorizer类提取的文本词频矩阵。 transform(X[, y]): 利用训练好的模型推断语料X中文档的主题分布。 fit_transform(X[, y]): 对输入语料（训练数据）训练LDA模型，并推断输入语料的主题分布。 perplexity(X[, doc_topic_distr, sub_sampling])：计算语料X的的困惑度。 模型训练与调参以困惑度（Perplexity）为基础调参&emsp;&emsp;LDA在进行训练之前，需要由算法设计人员指定主题数目参数n，主题数目的选择会在一定程度上影响主题检测的效果。 因此可以考虑计算Perplexity的值来帮助选主题数目参数。具体调参方式为： 指定主题的数目范围为：n_topics = range(min, max)。 对$min \leq n \leq max$进行LDA主题模型训练的迭代。计算每一次迭代的Perplexity。 绘制Perplexity与n_topics的曲线图，从图像最低点附近寻找最合适的参数。 类实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171from sklearn.feature_extraction.text import CountVectorizerfrom sklearn.decomposition import LatentDirichletAllocationfrom sklearn.externals import joblibclass LDATrain: def __init__(self, DocLst, NumTopics, MaxIter, MaxFeatures): """初始化，DocLst为输入的训练或测试文档""" self.DocLst = DocLst #输入参数，List类型数据结构，List中每一个元素为一个文档 self.NumTopics = NumTopics #话题数目 self.MaxIter = MaxIter #最大迭代数据 self.MaxFeatures = MaxFeatures #进行词频统计的最大数目 #计算词频时需要用到的变量 self.TFVectorizer = None self.TF = None #词频统计结果 #进行模型迭代时需要的变量 self.LDAModelLst = [] #迭代产生的LDA模型列表 self.PerplexityLst = [] #困惑度列表 self.BestIndex = None self.BestLDAModel = None #最佳LDA 模型 self.BestLDAModelPerplexity = None #最佳LDA模型的困惑度 self.BestTopicNum = None #最合适的主题数 def LDACountVectorizer(self, MaxDf = 0.95, MinDf = 2):#这个值还有待确认 """统计词频函数，调用CountVectorizer完成""" self.TFVectorizer = CountVectorizer(max_df = MaxDf,\ min_df = MinDf,\ max_features = self.MaxFeatures) self.TF = self.TFVectorizer.fit_transform(self.DocLst) def LDASaveTF(self, TFModelPath): """保存词频""" joblib.dump(self.TF, TFModelPath) def LDALoadVectorizer(self, TFModelPath): """导入之前计算得到的词频统计结果""" self.TF = joblib.load(TFModelPath) def LDATrain(self, NumTopic, MaxIter): """一次LDA训练，NumTopic为当前训练的主题数，MaxIter为最大迭代数""" LDAResult = LatentDirichletAllocation(n_components = NumTopic, \ max_iter = MaxIter,\ learning_method = 'batch',\ # evaluate_every = 200, \ # perp_tol = 0.01 ) # LDAResult.fit(self.TF) # TrainGamma = LDAResult.transform(self.TF) # TranPerplexity = LDAResult.perplexity(self.TF, TrainGamma) # return TrainGamma, TranPerplexity return LDAResult.fit(self.TF), LDAResult.perplexity(self.TF) def IterationLDATrain(self): """迭代训练最佳的LDA模型， NumTopics为包括所有可能的主题数一个list， MaxIter为一次LDA训练的最大迭代数""" #开始进行迭代训练 index = 0 for NumTopic in self.NumTopics: lda, perplexity = self.__LDATrain(NumTopic, self.MaxIter) self.LDAModelLst.append(lda) self.PerplexityLst.append(perplexity) print(index) index += 1 #保存最佳模型到 BestIndex = self.PerplexityLst.index(min(self.PerplexityLst))#获取最佳模型的索引 self.BestLDAModelPerplexity = min(self.PerplexityLst) self.BestTopicNum = self.NumTopics[BestIndex] self.BestLDAModel = self.LDAModelLst[BestIndex] self.BestIndex = BestIndex def TransformBestModel(self): for doc in self.TF: print(self.BestLDAModel.transform(doc)) def __print_top_Words(self, model, FeatureNames, NumTopWords): for topic_idx, topic in enumerate(model.components_): print("Topic #%d:" % topic_idx) print(" ".join([FeatureNames[i] for i in topic.argsort()[:-NumTopWords - 1:-1]])) def SaveTopicWords(self, NumTopWords, FilePath): """保存主题关键词，NumTopWord表示前多少个词""" TopicWords = "" FeatureNames = self.TFVectorizer.get_feature_names() for topic_idx, topic in enumerate(self.BestLDAModel.components_): TopicWords += "Topic #%d:" % topic_idx TopicWords += " ".join([FeatureNames[i] for i in topic.argsort()[:-NumTopWords - 1:-1]]) +'\n' f = open(FilePath + 'TopicWords.txt', 'w') f.write(TopicWords) f.close() def PrintBestModelAndPerplexity(self, NumTopWords): """打印出最佳模型""" print("Best Number of Topic in LDA Model is ", self.BestTopicNum) print("the min Perplexity is", self.BestLDAModelPerplexity) print("Best Model is \n") self.__print_top_Words(self.BestLDAModel, self.TFVectorizer.get_feature_names(), NumTopWords) def SaveAllLDAMode(self, FilePath): """保存所有LDAModel""" #检查该目录是否存在，若不存在则创建 CreateDir(FilePath) index = 0 for m in self.LDAModelLst: joblib.dump(m, FilePath + 'LDA-model-' + str(index) + '.model') index += 1 def SaveBestModel(self, FilePath): """保存最好的LDAmodel""" joblib.dump(self.BestLDAModel, FilePath + 'BestModel.model') def SavePerplexityCurveAndText(self, FilePath): """保存所有的困惑度（Perplexity），对应的曲线图像""" #检查该目录是否存在，若不存在则创建 CreateDir(FilePath) # 保存perplexity结果 with open(FilePath + 'Perplexity.txt', 'w') as f: PerplexityLstStr = "" index = 0 for x in self.PerplexityLst: PerplexityLstStr += str(index) + '|' + str(self.NumTopics[index]) + '|' + str(x) + '\n' index += 1 f.write(PerplexityLstStr) #绘制曲线并保存 plt.close('all') Figure = plt.figure() ax = Figure.add_subplot(1, 1, 1) ax.plot(self.NumTopics, self.PerplexityLst) ax.set_xlabel("# of topics") ax.set_ylabel("Approximate Perplexity") plt.grid(True) plt.savefig(FilePath + 'PerplexityTrend.png') #plt.show() def PrintDocTopicDist(self): """打印出文档关于主题的矩阵，每一行表示文档，列表示是当前主题概率""" doc_topic_dist = self.BestLDAModel.transform(self.TF) for idx, dist in enumerate(doc_topic_dist): # 注意：由于sklearn LDA函数限制，此函数中输出的topic_word矩阵未normalize dist = [str(x) for x in dist] print(str(idx + 1) + ',') print(','.join(dist) + '\n') def SaveDocTopicDist(self, FilePath): """保存出文档关于主题的矩阵，每一行表示文档，列表示是当前主题概率""" doc_topic_dist = self.BestLDAModel.transform(self.TF) DocTopic = '' for idx, dist in enumerate(doc_topic_dist): # 注意：由于sklearn LDA函数限制，此函数中输出的topic_word矩阵未normalize dist = [str(x) for x in dist] DocTopic += 'Document ' + str(idx + 1) + ':' +','.join(dist) + '\n' # print str(idx + 1) + ',' # print ','.join(dist) + '\n' f = open(FilePath + 'DocTopicDist.txt', 'w') f.write(DocTopic) f.close() def SaveConfigFile(self, FilePath): """保存文件配置""" f = open(FilePath + 'Config.txt', 'a') Config = \ 'k param = ' + str(max(self.NumTopics) + 1) + '\n' + \ 'MaxFeatures = ' + str(self.MaxFeatures) + '\n' + \ 'BestTopicNum = ' + str(self.BestTopicNum) + '\n' + \ 'BestIndex = ' + str(self.BestIndex) f.write(Config) f.close() 实验主题-Perplexity曲线图 从图中可以看出，困惑度的最低点是主题数为4时。 主题-关键词以下时主题数为4的主题-关键词分布。 Topic #0:couple counseling marriage therapy tip gloria relationship save saving expert help dr back get cambridgeTopic #1:today via thought bomber day go say im year love prayer http dont around affectedTopic #2:marathon explosion people new looking line injured finish runner victim friend today area via deadTopic #3:suspect bombing police marathon amp photo news say breaking local official officer fbi three area 从关键词的性质可以看出，主题的分类效果较好。 参考[1] 靳志辉,LDA数学八卦[M],2013.[2] https://blog.csdn.net/TiffanyRabbit/article/details/76445909 文中代码链接：https://github.com/zhaohuang123/sentiment-analysis/tree/master/blog/LDA]]></content>
      <categories>
        <category>机器学习</category>
        <category>主题模型</category>
      </categories>
      <tags>
        <tag>LDA</tag>
        <tag>sklearn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Jaccard Distance的K-Means++算法]]></title>
    <url>%2F2018%2F07%2F25%2FKMeansPP%2F</url>
    <content type="text"><![CDATA[本文的内容以基于Jaccard Distance的K-Means算法为基础，将原始K-Means算法随机选择初始向量的方法修改为K-Means++的概率选择方法，同样本文K-Means++算法的距离计算同样是基于Jaccard Distance距离的。 理论基础&emsp;&emsp;原始K-Means算法通过贪心策略，迭代化求解最小平方化误差（K-Means算法的求解过程实际上就是求解最小平方化误差）。但是由于其初始均值向量的选择具有随机性、不确定性，其算法不够稳定，有可能会造成迭代次数较多，算法时间复杂度较高。针对K-Means算法的问题，David Arthur等人提出了K-Means++算法. &emsp;&emsp;K-Means++算法与K-Means算法的主要差异在于初始均值的选取。选取初始均值向量算法如下： 随机从 $ D = \left[\vec x_1, \vec x_2,…,\vec x_m \right] $ 选取一个元素作为初始向量 $ \vec \mu_1 $. 按概率分布 $ \frac {D(\vec x)^2} {\sum_{\vec x \in D} D(\vec x)^2} $，从样本集D中随机选取新的初始均值向量$ \vec \mu_i $. 重复步骤2，直到选出k个初始均值向量。 &emsp;&emsp;上述算法中的$ D(x) $表示样本与均值向量集合的最短距离。 &emsp;&emsp;由上述算法可以看出，K-Means++算法的核心思想是：在初始均值向量选择时，尽可能选择相距较远的点。直观上理解即相聚越远的点位于不同簇的可能性越高，后续迭代优化的次数显然越少。 算法过程&emsp;&emsp;由于在基于Jaccard Distaance的K-Means中没有均值向量的计算，因此需要对原始K-Means++算法提出的初始向量选择方式进行改造。其算法流程如图。&emsp;&emsp;图中Seeds表示初始均值向量集合；DistanceMatrix存储所有样本与初始向量集合的最短距离；SumDist为DistanceMatrix的距离和；Seed为遍历Seeds集合指针；Probability为根据DistanceMatrix和SumDist计算出的每个样本的概率。&emsp;&emsp;图中算法流程为先将初始均值向量集合Seeds初始化为空集，再随机从样本集中选择一个样本作为初始均值向量加入到Seeds中，在整个流程中，仅有第一个初始均值向量是随机选择的。之后进入到计算新初始均值向量的循环中，每次循环都需要对DistanceMatrix、SumDist进行初始化，Seed指向集合Seeds中的第一个值。该循环的出口条件为Seeds集合元素个数大于k，即生成了k个初始均值向量时。 代码实现1234567891011121314151617181920212223242526def KMeansPPChooseSeeds(self): """K-Means++算法，用于选择初始均值向量""" #1a. Take one center c1, chosen uniformly at random from Tweets.（the english annotations are from D.Arthur paper ） seed = random.choice(list(self.tweets.keys())) #Take a new center ci, choosing x from X with probability D(x)^2 / Sum(D(xi)^2) seeds = set([seed]) while len(seeds) &lt; self.k: DistanceMatrix = &#123;&#125; SumSqrDist = 0 for seed in seeds: #V1 = set(self.tweets[seed].strip(' ').split(' ')) for ID in self.tweets: if ID == seed: continue #V2 = set(self.tweets[ID].strip(' ').split(' ')) Dist = self.JaccardDistance(self.tweets[seed], self.tweets[ID]) if ID not in DistanceMatrix or Dist &lt; DistanceMatrix[ID]: DistanceMatrix[ID] = Dist ProbabilityDict = &#123;&#125; for ID in DistanceMatrix: SumSqrDist += DistanceMatrix[ID] * DistanceMatrix[ID] for ID in DistanceMatrix: ProbabilityDict[ID] = DistanceMatrix[ID] * DistanceMatrix[ID] / SumSqrDist ##可以优化 实验结果实验结果与上一篇（基于Jaccard Distance的K-Means算法）基本相同。 参考[1] Arthur D, Vassilvitskii S. k-means++:the advantages of careful seeding[C] Eighteenth Acm-Siam Symposium on Discrete Algorithms, New Orleans, Louisiana. Society for Industrial and Applied Mathematics, 2007:1027-1035.[2] https://github.com/findkim/Jaccard-K-Means 文中代码链接： https://github.com/zhaohuang123/sentiment-analysis/tree/master/blog/K-Means%2B%2B]]></content>
      <categories>
        <category>机器学习</category>
        <category>聚类算法</category>
      </categories>
      <tags>
        <tag>Jaccard Distance</tag>
        <tag>K-Means++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Jaccard Distance的K-Means算法]]></title>
    <url>%2F2018%2F07%2F19%2FKMeansJD%2F</url>
    <content type="text"><![CDATA[本文主要是介绍如何以Jaccard Distance(JD)为基础，对Twitter的推文数据进行数据聚类。 理论基础性能度量方式 &emsp;&emsp;聚类性能度量级聚类 即聚类有效性指标（vlidity index），该指标可以分为两类：外部指标（external index），将聚类结果与某个“参考模型”比较；内部指标（internal index），直接分析聚类结果，不利用外部参考模型，以下给出两个内部指标度量方式：Dunn指数（Dunn Index，DI）以及误差平方和（Sum Of The Squared Errors，SSE）。 DI值在介绍DI值计算前，先需要计算以下两个值:diam(C) = max_{1 \leq i \leq j \leq |C| } dist(x_i,x_j)d_{min} (C_i,C_j) = min_{x_i \in C_i,x_j \in C_j} dist(x_i, x_j)其中$dist(.,.)$用于计算两个样本间的距离；$diam(C)$为簇$C$内样本的最远距离；$d_{min} (C_i,C_j)$为簇$C_i$与簇$C_j$最近样本间的距离。基于上述两个公式，DI值计算公式如下：DI = min_{1 \leq i \leq k} \left\{min_{j=i}\left(\frac {d_{min}(C_i,C_j)} {max{1 \leq l \leq k} diam(C_l)}\right)\right\}若要满足“簇间相似度低，簇内相似度高”，DI应越大越好 SSE值SSE值计算公式如下:SSE = \sum^k_{i=1} \sum^{|C_i|}_{p \in C_i}dist(p,\mu_i)^2SSE值判断聚类好坏的核心思想是：随着k参数的增大，样本的划分会更加精细，即“簇内相似度会增高”，因此，SSE值将随k参数递减。但当k参数小于真实聚类数时，k的增加会大幅度增加“簇内相似”程度，所以SSE值下降率会减小，图像上对应的曲线即是SSE值将会随着k的增加趋于平缓。综上，最合适的k值最可能为拐点处的k值。 距离计算方式在聚类计算中，距离计算函数$dsit(.,.)$需要满足以下四条性质： 非负性：$ dist(\vec x_i, \vec x_j) \geq 0 $ 同一性：$ dist(\vec x_i, \vec x_j) = 0 $ 当且仅当$ \vec x_i = \vec x_j $ 对称性：$ dist(\vec x_i, \vec x_j) = dist(\vec x_j, \vec x_i) $ 直递性：$ dist(\vec x_i, \vec x_j) \leq dist(\vec x_i, \vec x_k) + dist(\vec x_k, \vec x_j) $ Jaccard Distance 定义Jaccard系数（Jaccard Coefficient，JC）定义如下： J(A,B) = \frac {|A \bigcap B|}{|A \bigcup B|} = \frac {|A \bigcap B|}{|A| + |B| - |A \bigcap B|}Jaccard距离定义如下： d_J(A,B)=1-J(A,B)其中A,B为两个任意的集合 可行性证明由之前的JD定义可知，JD显然满足非负性、同一性、对称性这三种距离度量的基本性质，第四种性质“直递性”证明过程如下： JD直递性证明：假设有任意三个集合A,B,C，直递性要求有以下不等式成立： d_J(A,B) \leq d_J(A,C)+d_J(C,B)利用反证法证明上式，即假设有不等式：假设：d_J(A,B) > d_J(A,C)+d_J(C,B)成立，则根据假设不等式，A,B,C三个集合也满足如下不等式： d_J(A,C) > d_J(A,B)+d_J(B,C)对上述两个不等式进行迭代，则可以得到下式： d_J(A,B) > d_J(A,C) + d_J(C,B) > d_J(A,B) + d_J(B,C) + d_J(C,B)即有不等式： 0 > d_J(C,B) + d_J(B,C) = 2d_J(C,B)显然上式不满足JD所具有的非负性条件，因此假设不成立，原不等式成立。综合上述分析，JD直递性成立，满足四种距离计算的四种性质，JD可以作为距离度量方式 算法过程原始K-Means算法可以分为两个步骤，即外层控制聚类迭代次数以及新旧聚类簇对比，即若聚类簇不再更新或达到最大迭代次数，则推出外层循环，程序结束；内层循环控制新聚类簇的计算。算法流程如图。基于JD的K-Means算法与原始K-Means算法存在的差异为： 在基于JD的算法中，每轮迭代没有初始均值向量的再计算，则是直接计算新簇。 基于JD的K-Means算法没有样本向量化，而是直接使用样本集合的方式，以JD计算样本距离。 基于JD的K-Means算法计算新簇的流程如图上图中完整的计算过程包括三层循环，整体逻辑为：遍历样本每一个元素，对每一个元素遍历原始聚类中的每一个簇，计算每一个簇与样本的距离，将与样本距离最小的簇作为该样本的新簇。具体相关变量意义见代码实现。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339#!/usr/bin/python# -*- coding: UTF-8 -*-"""基于jaccard 距离的迭代K-Means算法实现"""# 一些功能函数import osdef CreateDir(FilePath): if not os.path.exists(FilePath): # 目录不存在时，创建目录 os.mkdir(FilePath)def WriteFileLine(FilePath, DataList, style): try: f = open(FilePath, style) for DataLine in DataList: f.write(DataLine) f.close() except Exception as e: print('Create File ERROR' + str(e))def ReadFile(FilePath): """读取预处理文件，返回值为Dict""" try: f = open(FilePath) except IOError: print("Can't find the file") return tweets = &#123;&#125; while True: line = f.readline() if not line: break try: ID = line.split('|')[0] Text = line.split('|')[1].strip('\n') tweets[ID] = set(Text.strip(' ').split(' ')) except IndexError: continue return tweetsimport copyimport random as Inrandomfrom numpy import randomimport timeclass KMeans: def __init__(self, tweets, k, MaxIterations): """初始参数，tweets为推文，数据类型为Dict，键：tweetID，值：分词后的tweet，以集合的形式保存 k为聚类簇数，MaxIterations为最大迭代次数'""" self.tweets = tweets self.k = k self.MaxIterations = MaxIterations self.seeds = []#随机选取的初始均值向量的ID self.Clusters = &#123;&#125;#用户存放聚类结果，字典之中的每一个键对应一簇 self.RevClusters = &#123;&#125;#反向索引，字典之中键为tweets向量ID，值为簇序号 self.JaccardMatrix = &#123;&#125;#设置为矩阵，用于存储每一对向量的jaccard距离 self.LenTwitter = len(tweets)#推文的长度 #运行初始均值向量随机选取函数 self.InitializeChooseSeeds() #运行初始化聚类函数 self.InitializeClusters() #运行计算Jaccard距离矩阵函数，修改：由于增加了LoadJaccardMatrix矩阵，所以不在__init__中直接运行， if self.LenTwitter &lt;= 1500: self.InitializeJaccardMatrix() def JaccardDistance(self, SetA, SetB): """计算Jaccard距离函数，SetA 和 SetB为两个集合""" try: return 1 - float(len(SetA.intersection(SetB))) / float(len(SetA.union(SetB))) except TypeError: print('Error, SetA or SetB is none.') def InitializeChooseSeeds(self): """kmeans算法，选取初始均值向量，利用sample函数，从tweets键中随机选取k个ID""" self.seeds = Inrandom.sample(list(self.tweets.keys()), self.k) def InitializeClusters(self): """对聚类进行初始化""" #对反向索引进行初始化，由于当前没有进行聚类，反向索引置为-1 for ID in self.tweets: self.RevClusters[ID] = -1 #对聚类簇字典进行初始化，初始化使用随机选取的初始均值向量 for i in range(self.k): self.Clusters[i] = set([self.seeds[i]]) #将tweet的ID以集合形式存储起来，i为簇序号也是字典键 self.RevClusters[self.seeds[i]] = i #初始均值向量对应的簇序号已经确定，对反向索引进行赋值 def InitializeJaccardMatrix(self): """计算出每一对tweet的Jaccard距离,动态规划思想，以空间换时间 数据量过大时，可能会发生memoryerror的错误 """ #利用两层循环进行每一对ID的匹配 k = 0 #调试变量 try: for ID1 in self.tweets: self.JaccardMatrix[ID1] = &#123;&#125; for ID2 in self.tweets: if ID2 not in self.JaccardMatrix: self.JaccardMatrix[ID2] = &#123;&#125; Distance = self.JaccardDistance(self.tweets[ID1], self.tweets[ID2])#计算出jaccard距离 self.JaccardMatrix[ID1][ID2] = Distance#距离赋值 self.JaccardMatrix[ID2][ID1] = Distance k += 1 except MemoryError: print(k) def LoadJaccardMatrix(self, FilePath): """导入已经计算好的Jaccard矩阵 数据格式为：ID1 | ID2 | Value """ try: f = open(FilePath, 'r') except IOError: print("Error! The file don't exist") return while True: line = f.readline() if not line: break try: #读出当前行的ID1 ID2 Distance ID1 = line.split('|')[0] ID2 = line.split('|')[1] Distance = float(line.split('|')[2]) #若不存在啊ID1 ID2等相关键，则进行创建 if ID1 not in self.JaccardMatrix: self.JaccardMatrix[ID1] = &#123;&#125; if ID2 not in self.JaccardMatrix: self.JaccardMatrix[ID2] = &#123;&#125; self.JaccardMatrix[ID1][ID2] = Distance # 距离赋值 self.JaccardMatrix[ID2][ID1] = Distance except IndexError: continue f.close() def CalcNewClusters(self): """计算新的聚类""" #初始化 NewClusters = &#123;&#125;#新的聚类 NewRevCluster = &#123;&#125;#新的反向索引 for i in range(self.k): NewClusters[i] = set()#初始化为空集 #遍历tweets中每一个元素，通过之前的聚类簇，构造出新的聚类 k = 0 #调试变量 for ID1 in self.tweets: MinDist = float("inf") #将最小距离初始化为无穷小，保证存在出口 MinCluster = self.RevClusters[ID1] #遍历每一个簇，计算出对于元素ID具有最小的簇数 for j in self.Clusters: #for j in SampleResult: Dist = 0 Count = float(0) #遍历当前簇之中的所有元素，计算出ID与其他元素的Jaccard之和 #计算当前ID与当前簇的距离 for ID2 in self.Clusters[j]: if self.LenTwitter &lt;= 1500: Dist += self.JaccardMatrix[ID1][ID2] else: Dist += 1 - \ float(len(self.tweets[ID1].intersection(self.tweets[ID2]))) \ / float(len(self.tweets[ID1].union(self.tweets[ID2]))) # 计算当前选定元素ID与该类之中其他元素的距离和 #Dist += self.jaccardMatrix[ID1][ID2] Count += 1 #计算当前类里元素的数量 k += 1 #调试变量 if Count &gt; 0:#若之前遍历的簇不为空，则进行距离判定 AvgDist = Dist / Count if MinDist &gt; AvgDist: #如果当前最小距离小于当前元素与该类的距离，则修改最小距离 MinDist = AvgDist MinCluster = j NewClusters[MinCluster].add(ID1)#将当前元素添加到具有最小距离的类中 NewRevCluster[ID1] = MinCluster#添加反向索引 return NewClusters, NewRevCluster#返回新的聚类结果 def Converge(self): """聚类顶层函数""" #初始化运行赋值 NewClusters, NewRevCluster = self.CalcNewClusters() self.Clusters = copy.deepcopy(NewClusters) self.RevClusters = copy.deepcopy(NewRevCluster) #开始进行迭代，直至收敛或达到最大迭代次数 Interations = 1 while Interations &lt; self.MaxIterations:#循环出口条件，小于最大迭代次数 NewClusters, NewRevCluster = self.CalcNewClusters() Interations += 1 if self.RevClusters != NewRevCluster: #当最新的迭代结果与之前结果不一致时，对聚类结果进行更新 self.Clusters = copy.deepcopy(NewClusters) self.RevClusters = copy.deepcopy(NewRevCluster) else:#若结果收敛，则循环结束，聚类完成 print(Interations) return Interations print('Get the Max!') return self.MaxIterations + 1 def OneClusterSSE(self, Cluster): """计算每一簇聚类之中的误差平方""" OneClusterSSE = 0 Len = len(Cluster) for ID1 in Cluster: S = 0 for ID2 in Cluster: if self.LenTwitter &lt;= 1500: S += self.JaccardMatrix[ID1][ID2] else: S += self.JaccardDistance(self.tweets[ID1], self.tweets[ID2]) S /= Len #S = S*S OneClusterSSE += S*S return OneClusterSSE def CalculateSSE(self): """用于计算误差平方和，Sum Of The Squared Errors, SSE""" SSE = 0 #误差平方和 for Ci in self.Clusters: SSE += self.OneClusterSSE(self.Clusters[Ci]) return SSE def CalculateMinValue(self, Cluster1, Cluster2): MinValue = float("inf")#表示值为无穷大 for ID1 in Cluster1: for ID2 in Cluster2: if self.LenTwitter &lt;= 1500: Dist = self.JaccardMatrix[ID1][ID2] else: Dist = self.JaccardDistance(self.tweets[ID1], self.tweets[ID2]) if MinValue &gt; Dist: MinValue = Dist return Dist def CalculateDiam(self,Cluster): """ 计算聚类之中元素的最大距离 :param Cluster: 输入聚类 :return: 返回最大值 """ Max = float('-inf')#令初始最大值为无限小，保证存在出口 for ID1 in Cluster: for ID2 in Cluster: if self.LenTwitter &lt;= 1500: dist = self.JaccardMatrix[ID1][ID2] else: dist = self.JaccardDistance(self.tweets[ID1], self.tweets[ID2]) if dist &gt; Max: Max = dist return Max def CalculateDI(self): """ 计算DI指数 :return: """ #先计算分子 DMin = float("inf") # 表示值为无穷大 for i in self.Clusters: for j in self.Clusters: if self.Clusters[i] is self.Clusters[j]: continue else: dist = self.CalculateMinValue(self.Clusters[i], self.Clusters[j]) if dist &lt; DMin: DMin = dist #在计算分母 DMax = float('-inf')#令初始最大值为无限小，保证存在出口 for l in self.Clusters: dist = self.CalculateDiam(self.Clusters[l]) if dist &gt; DMax: DMax = dist return DMin / DMax def PrintCluster(self): for i in self.Clusters: print('\n\nCluster ' + str(i)) for ID in self.Clusters[i]:#遍历簇中每一个ID以及ID对应的tweet print(str(ID) + ' | ' + ' '.join(self.tweets[ID]) + '\n') def PrintJaccardMatrix(self): for ID in self.tweets: for ID2 in self.tweets: print(ID, ID2, self.JaccardMatrix[ID][ID2]) def SaveClusterFile(self, FilePath): """以文件的形式保存聚类结果，FilePath为文件路径""" #若目录不存在，则创建路径 CreateDir(FilePath) #遍历每一个簇 for i in self.Clusters: TempCache = []#设置缓冲，存储当前簇中所有tweets for ID in self.Clusters[i]:#遍历簇中每一个ID以及ID对应的tweet #TempCache.append(str(ID) + '|' + self.tweets[ID] + '\n') #还需要修改了这一部分东西 TempCache.append(str(ID) + '|' + ' '.join(self.tweets[ID]) + '\n') # 还需要修改了这一部分东西 WriteFileLine(FilePath + 'C' + str(i) + '.txt', TempCache, 'w') def SaveJaccardMatrix(self, FilePath): """以文件的形式保存Jaccard矩阵计算结果，便于下次计算加速""" TempCache = []#设置缓冲 #遍历矩阵之中的每一个元素 for ID1 in self.tweets: for ID2 in self.tweets: TempCache.append(str(ID1) + '|' + str(ID2) + '|' + str(self.JaccardMatrix[ID1][ID2]) + '\n') #写入文件 try: WriteFileLine(FilePath + 'JaccardMatrix.txt', TempCache, 'w') except IOError: print("Error! The file fail to create!")def main(): tweets = ReadFile('ClusterTest.txt') k = 27 #设置k参数 MaxIterations = 50 #设置最大迭代次数 kmeans = KMeans(tweets, 27, MaxIterations) Iterations = kmeans.Converge() #方法返回最大迭代次数 kmeans.SaveClusterFile("ClusterResult/") SSE = kmeans.CalculateSSE() #计算SSE DI = kmeans.CalculateDI() #计算DI print("MaxIterations: " + str(MaxIterations) + "\n" + "SSE: " + str(SSE) + '\n' + "DI: " + str(DI))if __name__ == "__main__": time_start = time.time() # time.time()为1970.1.1到当前时间的毫秒数 main() time_end = time.time() # time.time()为1970.1.1到当前时间的毫秒数 print("the K-Means algorithm time:") print (str((time_end - time_start) / 60) + 'min') 实验结果针对1231条，时间在2013年4-5月的Boston地区的推文，运行聚类算法，实验结果如下：聚类结果中某一簇文件内容如下： 324772985196126208|dennis pen bombing oped lehane marathon330771754412818433|confronted bombing bomber suspect lol alleged news texted fox marathon326814744168235008|targeted racism yet balanced solidarity understands one marathon327104038778859520|mile dont runwalk april thursday arizona ims forget honorary marathon324887245570048000|bill running rodgers went champ beauty cant http time away take sportyou marathon325132502140329984|caught bombing firefight offi police another suspect loose watertown one marathon324190727141728256|take bombing terror marathon58361655649779712|trying figure townim strugglin get got324532692496551937|bombing keep calm marathon via carry323884448380776448|gi know pm running comment sarah area info pas anyone schulz someone marathon332630562231681026|pd bombing world suspect news abc fire didnt tell fbi marathon333606268113649665|wake bombing come event wacky bay area even antiterror campaign marathon 上述簇文件基本是包含的Boston爆炸事件的相关内容，可以看出，聚簇效果还是较为理想的。 参考[1] Arthur D, Vassilvitskii S. k-means++:the advantages of careful seeding[C] Eighteenth Acm-Siam Symposium on Discrete Algorithms, New Orleans, Louisiana. Society for Industrial and Applied Mathematics, 2007:1027-1035.[2] https://github.com/findkim/Jaccard-K-Means 文中代码链接：https://github.com/zhaohuang123/sentiment-analysis/tree/master/blog/K-Means]]></content>
      <categories>
        <category>机器学习</category>
        <category>聚类算法</category>
      </categories>
      <tags>
        <tag>K-Means</tag>
        <tag>Jaccard Distance</tag>
      </tags>
  </entry>
</search>
